一、基础

信息以字节为单位存储，即Byte。

1个Byte有8个bit,从高到低是7 6 5 4 3 2 1 0。

第7最高，叫MSB，Most Significant Bit。

第0最低，叫LSB，Least XX。


32位CPU一次操作可以处理32bit个二进制位。因此需要比字节更大的单位。

比如：字（16bit)、双字(32bit)


如果超过了1个Byte，就有个存储顺序的问题。

Inter存一个字，比如0x60 25,存的时候是0x25 0x60的顺序，这是little endian的方式。

Inter不要求字的地址是偶数，如果是偶数，则是一个对准字，如果不是，则称为未对准字。

对应的有big endian方式。在编程前这是首先应该搞清楚的问题。


数据表示

有符号整数用补码。如果用一个字表示一个数，当然有范围问题。

无符号数0～65535

有符号：-32768 ～ 32767

存正整数正常存，存负整数时保存的是数的绝对值取反加1。比如，保存－466，


0000 0001 1101 0010 ＝ 446


1111 1110 0010 1101 取反

1 加1

－－－－－－－－－－

1111 1110 0010 1110 实际保存的数，按照little endian保存，则0010 1110在前，1111 1110在后。


字符表示需要有一个映射表，ASCII最常用。用7个bit来表示字符。


汉字表示，中国是GB2312-80标准。用两个Byte表示一个汉字。标准映射了了6763个汉字，分成94个区，每区94个位，编号从0xA0开始，不占有ASCII 0x00～0x7F。每个汉字有唯一的区码和位码。


UNicode是另一种字符映射，它将全世界的字符都包括进来，也使用2个Byte。


BCD码，目的是将数据的输入和输出变得简单。存466时，如果用一个字，则

466 ＝ 0001 1101 0010 ＝ 0x01 D2

如果用BCD，则之间看成 0x04 0x66分别进行保存就行了，这是压缩BCD码。

如果不压缩，则看成0x04 0x06 0x06分别保存。

二、微处理器

AMD和Inter兼容，在程序员看来没有区别。


Pentium II III IV都是准64位的处理器。“准”是因为其外部总线64，地址总线32。一次内存总线操作可以存取8字节的数据，但内部寄存器和运算操作仍然是32位。


CPU结构上分成两部分，BIU（Bus Interface Unit）和EU（Execution Unit）


程序提供的数据、希望执行的指令通过BIU送到EU里执行，所以在BIU里肯定有个排队问题。排队的指令靠指令指针IP指明，排队的数据放到段寄存器（CS、DS、ES、SS）中。指令的物理地址是IP（偏移）和段寄存器CS内容相加的结果。16 ＋ 16形成20位的物理地址。因为有加法，所以BIU中还有地址加法器。




EU当然是执行和计算结果的了。所以肯定有算术/逻辑运算单元ALU。运算以后还是会有结果数据，BIU送过来的数据也要有地方保存，所以还是需要有寄存器，也就是通用寄存器。


还需要明确一遍的是，IP总是指向下一条待执行的指令。（题外话，缓冲器溢出很重要啊）

详细说说寄存器：
BIU中的段寄存器CS、DS、ES、SS，（可以这样想，他们和内存打交道，内存分段，所以叫段寄存器）

CS－代码段，用来找程序的指令序列。

DS－数据段

SS－堆栈段

ES－附加数据段


段寄存器中的数据指明了该段在内存中的起始地址。

比如CS，知道了指令序列的起点，当然还需要知道序列怎么排啊，所以用IP指明偏移。

IP，指令指针，指明某条指令在CS中的位置。程序运行时，IP的内容由CPU自动调整。

进到EU中，首先看到几个数据寄存器（可以这么想，他们和CPU处理的数据打交道，所以叫数据寄存器）


AX、BX、CX、DX

BIU送数据（专业点叫操作数）进到这里面来，EU执行的结果也送这里面来，然后再送出去。

四个寄存器各有专用。

AX，累加，使用频度最高，与外面交换数据，算术和逻辑运算它都参加。

BX，基址寄存器，存放存储器的地址。BIU如果送进来存储器的地址，它当然要参加。

CX，计数器。指令是循环或者串操作的话，它就参加。

DX，数据寄存器，存放外设端口地址，或者双字数据的高16位。

这四个寄存器都是16位，也可以分开用，表示成AH、AL。类似等等。

EU中还有堆栈指针寄存器SP，用于存放当前堆栈段中栈顶的偏移。

还有另一个基址寄存器BP。用来保存操作数或者运算结果。或者某存储单元的偏移，多用于对堆栈段中数据的非顺序存取。

变址寄存器SI，DI。SI是源变址寄存器，DI是目标变址寄存器。用来保存操作数或者运算结果。或者存放某存储单元的偏移地址。如果是数据块操作，则SI是源地址，DI是目标地址。

标志寄存器Flags。很重要的寄存器，表示CPU的状态及运算结果的特征。16位中共9个标志位。

什么是运算结果的特征呢？比如运算出现了溢出、运算结果是0、运算需要进位等等。

CPU状态又是什么呢？比如CPU是否允许中断等等。

具体说说：

15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0

OF DF IF TF SF ZF AF PF CF

AF：辅助进位，字节的低4位向高4位进位，字的低字节向高字节进位等等。

CF：结果的最高位有进位。

OF：结果溢出

SF：符号标志，和结构的最高位保持相同。1表示结果是负数。

PF：奇偶标志，结果中低8位1的个数是奇是偶

ZF：0标准，结果是0

DF：方向标志，对字符串操作指令有效，为0，则操作自动增址，为1则自动减址。

IF：中断允许

TF：单步标志，CPU进不进单步执行方式。

和内存打交道，需要对存储器分段

存储器越来越大，因此引入分段手段。分段以后，就在物理地址之外出现了逻辑地址。逻辑地址表示成段的开始地址加上偏移。也就是“段首址：偏移”。

如果划分段的标准不同，就会出现同一个物理地址有多个逻辑地址。

和外部设备打交道，需要使用I/O的地址空间

每个外部设备的接口中都有寄存器和端口地址，这是打交道的桥梁。CPU有专门读写I/O的指令，称为I/O指令。I/O地址从0000H～FFFFH，不需要分段。

CPU三种工作模式：

实模式、保护模式和虚拟86模式。

计算机启动时运行在实模式下。所有指令工作在特权级0。


保护模式是主要模式，提供Windows 32位程序运行。提供多任务、内存分段分页和特权级管理和虚拟内存的使用。

为了保持原DOS 16程序，提供虚拟模式。


Windows下的Pagefile.sys3是虚拟内存的交换文件。

Windows将内存空间分成两部分，用户地址空间和系统地址空间。


用户地址空间中，“堆”是一个很大的内存空间，可以用malloc和free从堆中分配和释放内存空间。

有四个特权级，0～3，0最高。


Windows只使用0和3。


CS段的最低两位表示当前运行程序的特权级。0级为0x0008，3级为0x0023